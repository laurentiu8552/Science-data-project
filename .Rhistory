str(data)
# Convert the 'date' column to Date type
data$date <- as.Date(data$date, format = "%d.%m.%Y")
# Convert all non-numeric columns (besides 'date') to factors
data[] <- lapply(data, function(x) if(is.character(x)) as.factor(x) else x)
# Check the structure of the dataset to confirm the changes
str(data)
# Rename the column 'order_value_ex_vat_ex_freight' to 'Revenue'
data <- data %>%
dplyr::rename(revenue = order_value_ex_vat_ex_freight)
str(data)
#APPLICATION 2
#starting with descriptive statistics
#Cleaning the data on na customers but also revenue above 0
data_application2 <- data %>%
filter(!is.na(customer_id))
#DESCRIPTIVE STATISTICS
#### NR of orders per month ####
# Extract month and year from the date
data_application2$date_month <- format(as.Date(data_application2$date), "%Y-%m")
# Plot number of orders per month
ggplot(data_application2) +
geom_bar(aes(x = date_month), colour = "grey20", fill = "grey80") +
ggtitle("Orders per Month") +
xlab("Month") +
ylab("Number of Orders") +
theme(panel.background = element_rect(fill = "grey94")) +
theme(plot.title = element_text(hjust = 0.5)) +
theme(axis.text = element_text(size = 14, angle = 45, hjust = 1),  # Rotate text to 45 degrees
axis.title = element_text(size = 14))
#### NR of orders per customer####
# Truncate orders per customer
# Step 1: Calculate the number of orders per customer
order_count_per_customer <- table(data_application2$customer_id)
# Step 2: Truncate the number of orders to 15
order_count_truncate <- pmin(order_count_per_customer, 15)
# Step 3: Create a data frame for plotting
order_summary <- as.data.frame(table(order_count_truncate))
# Step 4: Plot the number of orders per customer using a bar plot
ggplot(order_summary, aes(x = as.factor(order_count_truncate), y = Freq)) +
geom_bar(stat = "identity", fill = "grey80", colour = "grey20") +
ggtitle("Orders per Customer (Truncated to 15)") +
xlab("Total Number of Orders") +
ylab("Number of Customers") +
theme(panel.background = element_rect(fill = "grey94")) +
theme(plot.title = element_text(hjust = 0.5)) +
theme(axis.text = element_text(size = 14), axis.title = element_text(size = 14))
####  Days Between Orders  ####
# Sort data by customer_id and date
data_application2 <- data_application2 %>%
arrange(customer_id, date)
# Calculate days since the last order for each customer
data_application2 <- data_application2 %>%
group_by(customer_id) %>%
mutate(days_since_last_order = as.numeric(difftime(date, lag(date), units = "days"))) %>%
ungroup()
# Replace NA values (for the first order) with 0
data_application2$days_since_last_order[is.na(data_application2$days_since_last_order)] <- 0
# Remove customers with only one order (days_since_last_order = 0)
data_application2_filtered <- data_application2 %>%
filter(days_since_last_order > 0)
# Now create the subset for the relevant columns (order_id, customer_id, days_since_last_order)
daysdata <- subset(data_application2_filtered[, c("order_id", "customer_id", "days_since_last_order")])
# Calculate the mean of the days_since_last_order for each customer
daysdatamean <- aggregate(days_since_last_order ~ customer_id, data = daysdata, FUN = mean)
# Plot histogram of the days between orders
ggplot(daysdatamean) +
geom_histogram(aes(x = days_since_last_order), binwidth = 5, colour = "grey20", fill = "grey80") +
ggtitle("Days Between Orders customers with at least 2 orders") +
xlab("Average Days Between Orders") +
ylab("Number of Customers") +
theme(panel.background = element_rect(fill = "grey94")) +
theme(plot.title = element_text(hjust = 0.5)) +
theme(axis.text = element_text(size = 17, face = "plain"),
axis.title = element_text(size = 17, face = "plain"),
title = element_text(size = 16, face = "plain"))
#### Postal code distribution - also matching with acutal cities #####
# Read the postal codes data file
postal_codes <- read.csv("postal_codes_Romania.csv")
# Convert all columns to factors in the postal_codes dataframe
postal_codes[] <- lapply(postal_codes, as.factor)
# Convert all non-numeric columns to factors in the data_application2 dataframe
data_application2[] <- lapply(data_application2, function(x) if (is.character(x)) as.factor(x) else x)
# Ensure that the postal_code and customer_zip_code are both of the same type (character for this case)
postal_codes$postal_code <- as.character(postal_codes$postal_code)
data_application2$customer_zip_code <- as.character(data_application2$customer_zip_code)
# Filter out rows with NA in both customer_zip_code and postal_code columns
data_application2_filtered <- data_application2 %>%
filter(!is.na(customer_zip_code))  # Remove rows with NA in customer_zip_code
app2_subset <- subset(data_application2_filtered[, c("customer_id", "customer_zip_code")])
app2_subset <- app2_subset%>%
dplyr::rename(postal_code = customer_zip_code)
str(app2_subset)
#filter the postal one
postal_codes_filtered <- postal_codes %>%
filter(!is.na(postal_code))  # Remove rows with NA in postal_code
postal_subset <- subset(postal_codes_filtered[, c("postal_code", "judet")])
#filter the postal one
postal_codes_filtered <- postal_codes %>%
filter(!is.na(postal_code))  # Remove rows with NA in postal_code
postal_subset <- subset(postal_codes_filtered[, c("postal_code", "Judet")])
str(postal_subset)
# Assuming app2_subset and postal_subset are already defined
# Join the app2_subset with postal_subset based on the postal_code
joined_data <- app2_subset %>%
dplyr::left_join(postal_subset, by = "postal_code") %>%
mutate(matched_postal_code = coalesce(postal_code, postal_code))
str(joined_data)
# Ensure 'judet' is treated as a character and 'customer_id' is numeric
joined_data$judet <- as.character(joined_data$judet)
#### Postal code distribution - also matching with acutal cities #####
# Read the postal codes data file
postal_codes <- read.csv("postal_codes_Romania.csv")
# Convert all columns to factors in the postal_codes dataframe
postal_codes[] <- lapply(postal_codes, as.factor)
# Convert all non-numeric columns to factors in the data_application2 dataframe
data_application2[] <- lapply(data_application2, function(x) if (is.character(x)) as.factor(x) else x)
# Ensure that the postal_code and customer_zip_code are both of the same type (character for this case)
postal_codes$postal_code <- as.character(postal_codes$postal_code)
data_application2$customer_zip_code <- as.character(data_application2$customer_zip_code)
# Filter out rows with NA in both customer_zip_code and postal_code columns
data_application2_filtered <- data_application2 %>%
filter(!is.na(customer_zip_code))  # Remove rows with NA in customer_zip_code
app2_subset <- subset(data_application2_filtered[, c("customer_id", "customer_zip_code")])
app2_subset <- app2_subset%>%
dplyr::rename(postal_code = customer_zip_code)
str(app2_subset)
#filter the postal one
postal_codes_filtered <- postal_codes %>%
filter(!is.na(postal_code))  # Remove rows with NA in postal_code
postal_subset <- subset(postal_codes_filtered[, c("postal_code", "Judet")])
str(postal_subset)
# Assuming app2_subset and postal_subset are already defined
# Join the app2_subset with postal_subset based on the postal_code
joined_data <- app2_subset %>%
dplyr::left_join(postal_subset, by = "postal_code") %>%
mutate(matched_postal_code = coalesce(postal_code, postal_code))
str(joined_data)
# Ensure 'Judet' is treated as a character and 'customer_id' is numeric
joined_data$Judet <- as.character(joined_data$Judet)
# Ensure the encoding of Judet is correct (UTF-8)
joined_data$Judet <- iconv(joined_data$Judet, from = "UTF-8", to = "ASCII//TRANSLIT")
# Count the occurrences of each Judet
Judet_counts <- table(joined_data$Judet)
# Sort the counts in descending order
Judet_counts_sorted <- sort(Judet_counts, decreasing = TRUE)
# Create a bar plot of the sorted Judet counts
barplot(Judet_counts_sorted,
main = "Count of Customers per Judet (Sorted)",
xlab = "Judet",
ylab = "Count of Customers",
las = 2,  # Rotate x-axis labels for readability
col = "steelblue")
View(joined_data)
# Ensure 'Judet' is treated as a character and 'customer_id' is numeric
joined_data$Judet <- as.character(joined_data$Judet)
# Ensure the encoding of Judet is correct (UTF-8)
joined_data$Judet <- iconv(joined_data$Judet, from = "UTF-8", to = "ASCII//TRANSLIT")
# Count the occurrences of each Judet
Judet_counts <- table(joined_data$Judet)
# Sort the counts in descending order
Judet_counts_sorted <- sort(Judet_counts, decreasing = TRUE)
# Create a bar plot of the sorted Judet counts
barplot_heights <- barplot(Judet_counts_sorted,
main = "Count of Customers per Judet (Sorted)",
xlab = "Judet",
ylab = "Count of Customers",
las = 2,  # Rotate x-axis labels for readability
col = "steelblue")
# Add the customer count on top of each bar
text(barplot_heights,
height = Judet_counts_sorted,
labels = Judet_counts_sorted,
pos = 3,   # Position of the labels above the bars
cex = 0.8, # Size of the labels
col = "black")  # Color of the labels
# Ensure 'Judet' is treated as a character and 'customer_id' is numeric
joined_data$Judet <- as.character(joined_data$Judet)
# Ensure the encoding of Judet is correct (UTF-8)
joined_data$Judet <- iconv(joined_data$Judet, from = "UTF-8", to = "ASCII//TRANSLIT")
# Count the occurrences of each Judet
Judet_counts <- table(joined_data$Judet)
# Sort the counts in descending order
Judet_counts_sorted <- sort(Judet_counts, decreasing = TRUE)
# Create a bar plot of the sorted Judet counts
barplot_heights <- barplot(Judet_counts_sorted,
main = "Count of Customers per Judet (Sorted)",
xlab = "Judet",
ylab = "Count of Customers",
las = 2,  # Rotate x-axis labels for readability
col = "steelblue",
cex.names = 0.6)  # Reduce the size of X-axis labels
# Count how many NAs are in the 'Judet' column
na_count_judet <- sum(is.na(joined_data$Judet))
# Print the result
print(na_count_judet)
#### PLOT ####
# Ensure 'Judet' is treated as a character and 'customer_id' is numeric
joined_data$Judet <- as.character(joined_data$Judet)
# Ensure the encoding of Judet is correct (UTF-8)
joined_data$Judet <- iconv(joined_data$Judet, from = "UTF-8", to = "ASCII//TRANSLIT")
# Count the occurrences of each Judet
Judet_counts <- table(joined_data$Judet)
# Sort the counts in descending order
Judet_counts_sorted <- sort(Judet_counts, decreasing = TRUE)
# Create a bar plot of the sorted Judet counts
barplot_heights <- barplot(Judet_counts_sorted,
main = "Count of Customers per Judet (Sorted)",
xlab = "Judet",
ylab = "Count of Customers",
las = 2,  # Rotate x-axis labels for readability
col = "steelblue",
cex.names = 0.6)  # Reduce the size of X-axis labels
# Count how many NAs are in the 'Judet' column
na_count_judet <- sum(is.na(joined_data$Judet))
# Print the result
print(na_count_judet)
# Replace NA in 'Judet' with 'Bucuresti'
joined_data$Judet[is.na(joined_data$Judet)] <- "Bucuresti"
# Check the result to make sure NAs were replaced
sum(is.na(joined_data$Judet))  # Should return 0 if all NAs are replaced
# Replace NA in 'Judet' with 'Bucuresti'
joined_data$Judet[is.na(joined_data$Judet)] <- "Bucuresti"
# Check the result to make sure NAs were replaced
sum(is.na(joined_data$Judet))  # Should return 0 if all NAs are replaced
# Ensure 'Judet' is treated as a character and 'customer_id' is numeric
joined_data$Judet <- as.character(joined_data$Judet)
# Ensure the encoding of Judet is correct (UTF-8)
joined_data$Judet <- iconv(joined_data$Judet, from = "UTF-8", to = "ASCII//TRANSLIT")
# Count the occurrences of each Judet
Judet_counts <- table(joined_data$Judet)
# Sort the counts in descending order
Judet_counts_sorted <- sort(Judet_counts, decreasing = TRUE)
# Create a bar plot of the sorted Judet counts
barplot_heights <- barplot(Judet_counts_sorted,
main = "Count of Customers per Judet (Sorted)",
xlab = "Judet",
ylab = "Count of Customers",
las = 2,  # Rotate x-axis labels for readability
col = "steelblue",
cex.names = 0.6)  # Reduce the size of X-axis labels
# Count how many NAs are in the 'Judet' column
na_count_judet <- sum(is.na(joined_data$Judet))
# Print the result
print(na_count_judet)
# Replace NA in 'Judet' with 'Bucuresti'
joined_data$Judet[is.na(joined_data$Judet)] <- "Bucuresti and others"
# Check the result to make sure NAs were replaced
sum(is.na(joined_data$Judet))  # Should return 0 if all NAs are replaced
# Ensure 'Judet' is treated as a character and 'customer_id' is numeric
joined_data$Judet <- as.character(joined_data$Judet)
# Ensure the encoding of Judet is correct (UTF-8)
joined_data$Judet <- iconv(joined_data$Judet, from = "UTF-8", to = "ASCII//TRANSLIT")
# Count the occurrences of each Judet
Judet_counts <- table(joined_data$Judet)
# Sort the counts in descending order
Judet_counts_sorted <- sort(Judet_counts, decreasing = TRUE)
# Create a bar plot of the sorted Judet counts
barplot_heights <- barplot(Judet_counts_sorted,
main = "Count of Customers per Judet (Sorted)",
xlab = "Judet",
ylab = "Count of Customers",
las = 2,  # Rotate x-axis labels for readability
col = "steelblue",
cex.names = 0.6)  # Reduce the size of X-axis labels
# Count how many NAs are in the 'Judet' column
na_count_judet <- sum(is.na(joined_data$Judet))
# Print the result
print(na_count_judet)
install.packages("tidygeocoder")
install.packages("sf")
# Get unique Judet names (remove duplicates)
unique_judets <- unique(joined_data$Judet)
# Geocode Judet names to get latitude and longitude
geocoded_judets <- tidygeocoder::geocode(unique_judets, method = 'osm')
# Install and load the necessary libraries
# install.packages("tidygeocoder")
# install.packages("sf")
# install.packages("ggplot2")
library(tidygeocoder)
library(sf)
library(ggplot2)
# Get unique Judet names (remove duplicates)
unique_judets <- unique(joined_data$Judet)
# Geocode Judet names to get latitude and longitude
geocoded_judets <- tidygeocoder::geocode(unique_judets, method = 'osm')
#### BONUS #####
# Install and load the necessary libraries
# install.packages("tidygeocoder")
# install.packages("sf")
# install.packages("ggplot2")
library(tidygeocoder)
library(sf)
library(ggplot2)
# Get unique Judet names (remove duplicates) and convert to dataframe
unique_judets_df <- data.frame(Judet = unique(joined_data$Judet))
# Geocode Judet names to get latitude and longitude
geocoded_judets <- tidygeocoder::geocode(unique_judets_df, method = 'osm')
# Install and load the necessary libraries
# install.packages("tidygeocoder")
# install.packages("sf")
# install.packages("ggplot2")
library(tidygeocoder)
library(sf)
library(ggplot2)
# Get unique Judet names (remove duplicates) and convert to dataframe
unique_judets_df <- data.frame(Judet = unique(joined_data$Judet))
# Geocode Judet names to get latitude and longitude
# Specify 'address' column explicitly in geocode function
geocoded_judets <- tidygeocoder::geocode(unique_judets_df, address = "Judet", method = 'osm')
# Merge geocoded data back with customer data to include coordinates
judet_geo_data <- data.frame(Judet = unique_judets_df$Judet,
Latitude = geocoded_judets$lat,
Longitude = geocoded_judets$long)
# Count occurrences of each Judet in your original dataset
Judet_counts <- table(joined_data$Judet)
Judet_counts_df <- data.frame(Judet = names(Judet_counts), Count = as.vector(Judet_counts))
# Merge the counts with the geocoded data
geo_count_data <- merge(judet_geo_data, Judet_counts_df, by = "Judet")  # Convert to sf object for spatial plotting
# Convert the data to an sf object for spatial plotting
geo_count_sf <- st_as_sf(geo_count_data, coords = c("Longitude", "Latitude"), crs = 4326)
# Plot the map with customer counts
ggplot(geo_count_sf) +
geom_sf(aes(color = Count, size = Count), alpha = 0.7) +  # Customize size/color of points
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom")
# Install and load necessary libraries
# install.packages("ggspatial")
library(tidygeocoder)
library(sf)
library(ggplot2)
library(ggspatial)
install.packages(ggspatial)
install.packages("ggspatial")
# Install and load necessary libraries
# install.packages("ggspatial")
library(tidygeocoder)
library(sf)
library(ggplot2)
library(ggspatial)
# Get unique Judet names (remove duplicates) and convert to dataframe
unique_judets_df <- data.frame(Judet = unique(joined_data$Judet))
# Geocode Judet names to get latitude and longitude
geocoded_judets <- tidygeocoder::geocode(unique_judets_df, address = "Judet", method = 'osm')
# Merge geocoded data back with customer data to include coordinates
judet_geo_data <- data.frame(Judet = unique_judets_df$Judet,
Latitude = geocoded_judets$lat,
Longitude = geocoded_judets$long)
# Count occurrences of each Judet in your original dataset
Judet_counts <- table(joined_data$Judet)
Judet_counts_df <- data.frame(Judet = names(Judet_counts), Count = as.vector(Judet_counts))
# Merge the counts with the geocoded data
geo_count_data <- merge(judet_geo_data, Judet_counts_df, by = "Judet")  # Convert to sf object for spatial plotting
# Convert the data to an sf object for spatial plotting
geo_count_sf <- st_as_sf(geo_count_data, coords = c("Longitude", "Latitude"), crs = 4326)
# Create the plot
ggplot() +
# Add a world map background for context
annotation_map_tile(type = "stamen", zoom = 2) +  # You can adjust the zoom level here
# Add Romania's customer data as points
geom_sf(data = geo_count_sf, aes(color = Count, size = Count), alpha = 0.7) +
# Add labels for Judets, adjusting size and position to avoid overlap
geom_sf_text(data = geo_count_sf, aes(label = Judet), size = 3,
nudge_y = 0.02, nudge_x = 0.02, check_overlap = TRUE) +  # Adjust position if needed
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet (Romania)", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom") +
coord_sf(xlim = c(20, 30), ylim = c(44, 48))  # Zoom into Romania (adjust coordinates if needed)
install.packages("prettymapr")
# Install and load necessary libraries
# install.packages("ggspatial")
library(tidygeocoder)
library(sf)
library(ggplot2)
library(ggspatial)
library(prettymapr)
# Get unique Judet names (remove duplicates) and convert to dataframe
unique_judets_df <- data.frame(Judet = unique(joined_data$Judet))
# Geocode Judet names to get latitude and longitude
geocoded_judets <- tidygeocoder::geocode(unique_judets_df, address = "Judet", method = 'osm')
# Merge geocoded data back with customer data to include coordinates
judet_geo_data <- data.frame(Judet = unique_judets_df$Judet,
Latitude = geocoded_judets$lat,
Longitude = geocoded_judets$long)
# Count occurrences of each Judet in your original dataset
Judet_counts <- table(joined_data$Judet)
Judet_counts_df <- data.frame(Judet = names(Judet_counts), Count = as.vector(Judet_counts))
# Merge the counts with the geocoded data
geo_count_data <- merge(judet_geo_data, Judet_counts_df, by = "Judet")  # Convert to sf object for spatial plotting
# Convert the data to an sf object for spatial plotting
geo_count_sf <- st_as_sf(geo_count_data, coords = c("Longitude", "Latitude"), crs = 4326)
# Create the plot
ggplot() +
# Add a world map background for context
annotation_map_tile(type = "stamen", zoom = 2) +  # You can adjust the zoom level here
# Add Romania's customer data as points
geom_sf(data = geo_count_sf, aes(color = Count, size = Count), alpha = 0.7) +
# Add labels for Judets, adjusting size and position to avoid overlap
geom_sf_text(data = geo_count_sf, aes(label = Judet), size = 3,
nudge_y = 0.02, nudge_x = 0.02, check_overlap = TRUE) +  # Adjust position if needed
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet (Romania)", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom") +
coord_sf(xlim = c(20, 30), ylim = c(44, 48))  # Zoom into Romania (adjust coordinates if needed)
# Create the plot with a world map background using ggspatial
ggplot() +
# Add a world map background for context
annotation_map_tile(type = "osm", zoom = 2) +  # You can adjust the zoom level here
# Add Romania's customer data as points
geom_sf(data = geo_count_sf, aes(color = Count, size = Count), alpha = 0.7) +
# Add labels for Judets, adjusting size and position to avoid overlap
geom_sf_text(data = geo_count_sf, aes(label = Judet), size = 3,
nudge_y = 0.02, nudge_x = 0.02, check_overlap = TRUE) +  # Adjust position if needed
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet (Romania)", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom") +
coord_sf(xlim = c(20, 30), ylim = c(44, 48))  # Zoom into Romania (adjust coordinates if needed)
# Create the plot with a world map background using ggspatial
ggplot() +
# Use a lower zoom level and change the tile provider to 'Stamen'
annotation_map_tile(type = "stamen", zoom = 3) +  # Lower zoom level
# Add Romania's customer data as points
geom_sf(data = geo_count_sf, aes(color = Count, size = Count), alpha = 0.7) +
# Add labels for Judets, adjusting size and position to avoid overlap
geom_sf_text(data = geo_count_sf, aes(label = Judet), size = 3,
nudge_y = 0.02, nudge_x = 0.02, check_overlap = TRUE) +  # Adjust position if needed
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet (Romania)", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom") +
coord_sf(xlim = c(20, 30), ylim = c(44, 48))  # Zoom into Romania (adjust coordinates if needed)
install.packages("ggmap")
# Install and load necessary libraries
# install.packages("ggspatial")
library(tidygeocoder)
library(sf)
library(ggplot2)
library(ggspatial)
library(prettymapr)
library(ggmap)
# Get unique Judet names (remove duplicates) and convert to dataframe
unique_judets_df <- data.frame(Judet = unique(joined_data$Judet))
# Geocode Judet names to get latitude and longitude
geocoded_judets <- tidygeocoder::geocode(unique_judets_df, address = "Judet", method = 'osm')
# Merge geocoded data back with customer data to include coordinates
judet_geo_data <- data.frame(Judet = unique_judets_df$Judet,
Latitude = geocoded_judets$lat,
Longitude = geocoded_judets$long)
# Count occurrences of each Judet in your original dataset
Judet_counts <- table(joined_data$Judet)
Judet_counts_df <- data.frame(Judet = names(Judet_counts), Count = as.vector(Judet_counts))
# Merge the counts with the geocoded data
geo_count_data <- merge(judet_geo_data, Judet_counts_df, by = "Judet")  # Convert to sf object for spatial plotting
# Convert the data to an sf object for spatial plotting
geo_count_sf <- st_as_sf(geo_count_data, coords = c("Longitude", "Latitude"), crs = 4326)
library(ggplot2)
library(ggspatial)
library(sf)
library(viridis)
library(ggmap)
# Register Google Maps API key if using Google Maps
# register_google(key = "your_api_key")  # Optional, only if using Google tiles
# Create the plot with a world map background using ggmap
ggplot() +
# Use ggmap to get a background map
annotation_raster(ggmap::get_map(location = c(lon = 25, lat = 45), zoom = 6, source = "stamen", maptype = "terrain"),
xmin = 20, xmax = 30, ymin = 44, ymax = 48) +  # Define map limits
# Add Romania's customer data as points
geom_sf(data = geo_count_sf, aes(color = Count, size = Count), alpha = 0.7) +
# Add labels for Judets, adjusting size and position to avoid overlap
geom_sf_text(data = geo_count_sf, aes(label = Judet), size = 3,
nudge_y = 0.02, nudge_x = 0.02, check_overlap = TRUE) +  # Adjust position if needed
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet (Romania)", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom") +
coord_sf(xlim = c(20, 30), ylim = c(44, 48))  # Zoom into Romania (adjust coordinates if needed)
# Install and load the necessary libraries
# install.packages("tidygeocoder")
# install.packages("sf")
# install.packages("ggplot2")
library(tidygeocoder)
library(sf)
library(ggplot2)
# Get unique Judet names (remove duplicates) and convert to dataframe
unique_judets_df <- data.frame(Judet = unique(joined_data$Judet))
# Geocode Judet names to get latitude and longitude
# Specify 'address' column explicitly in geocode function
geocoded_judets <- tidygeocoder::geocode(unique_judets_df, address = "Judet", method = 'osm')
# Merge geocoded data back with customer data to include coordinates
judet_geo_data <- data.frame(Judet = unique_judets_df$Judet,
Latitude = geocoded_judets$lat,
Longitude = geocoded_judets$long)
# Count occurrences of each Judet in your original dataset
Judet_counts <- table(joined_data$Judet)
Judet_counts_df <- data.frame(Judet = names(Judet_counts), Count = as.vector(Judet_counts))
# Merge the counts with the geocoded data
geo_count_data <- merge(judet_geo_data, Judet_counts_df, by = "Judet")  # Convert to sf object for spatial plotting
# Convert the data to an sf object for spatial plotting
geo_count_sf <- st_as_sf(geo_count_data, coords = c("Longitude", "Latitude"), crs = 4326)
# Plot the map with customer counts
ggplot(geo_count_sf) +
geom_sf(aes(color = Count, size = Count), alpha = 0.7) +  # Customize size/color of points
scale_color_viridis_c() +  # Color scale for customer counts
labs(title = "Customer Counts per Judet", fill = "Customer Count") +
theme_minimal() +
theme(legend.position = "bottom")
